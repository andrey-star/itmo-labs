-- 1

-- StudentId - PK => делаем индекс. hash т.к. получим быстрые запросы
--   на получение имени, а эффективно сделать покрывающим не
--   получится и сортировка id не нужна.
-- ДЗ-5.1.1. Информация о студентах по :StudentId
-- ДЗ-5.2.1. Полная информация о студентах по :StudentId
-- ДЗ-7.2.1. Изменение имени студента
create unique index on Students using hash (StudentId)

-- GroupId - FK => делаем индекс. hash т.к. получим быстрые запросы
--   на получение студентов заданной группы, а эффективно сделать
--   покрывающим не получится и сортировка id не нужна.
-- ДЗ-5.3.3. Информацию о студентах с :Mark по предмету :LecturerId
-- ДЗ-6.1.2. Информация о студентах по :GroupName
-- ДЗ-7.2.3. Перевод всех студентов группы по :*GroupId
create index on Students using hash (GroupId)

-- Хотим по StudentName быстро получать StudentId - делаем индекс.
--   btree т.к. можем добавить GroupId не сильно пожертвов
--   ветвистостью дерева, при этом будем сразу получать GroupId при
--   запросах по имени. Хранить студентов осторитрованными полезно,
--   т.к. они почти всегда требуются в алфавитном порядке.
-- ДЗ-5.1.2. Информация о студентах по :StudentName
-- ДЗ-5.2.2. Полная информация о студентах по :StudentName
-- ДЗ-6.1.1. Информация о студентах по :StudentName
create index on Students using btree (StudentName, StudentId, GroupId)

-- GroupId - PK => делаем индекс. hash т.к. получим быстрые запросы
--   на получение имени, а эффективно сделать покрывающим не
--   получится (GroupName сильно ухудшит ветвистость).
-- ДЗ-5.2.1. Полная информация о студентах по :StudentId
-- ДЗ-5.2.2. Полная информация о студентах по :StudentName
-- ДЗ-6.2.1. Полная информация о всех студентах
create unique index on Groups using hash (GroupId)

-- Хотим по GroupName быстро получать GroupId - делаем индекс. hash
--   т.к. запросов по префиксу в ДЗ 5-7 не было, сортировка Id не
--   требуется. Однако btree с добавленным GroupId может работать
--   лучше, поэтому cтоит попробовать оба варианта и выбрать лучший.
-- ДЗ-6.1.2. Информация о студентах по :GroupName
-- ДЗ-7.2.4. Перевод всех студентов группы по :*GroupName
-- ДЗ-7.2.5. Перевод всех студентов в существующую группу
create index on Groups using hash (GroupName)

-- CourseId - PK => делаем индекс. hash т.к. получим быстрые
--   запросы, а эффективно сделать покрывающим не получится и
--   сортировка id не нужна.
-- ДЗ-5.3.2 Информация о студентах с :Mark по предмету :CourseName
-- ДЗ-5.4.1 Информацию о студентах не имеющих оценки по :CourseName
--   среди всех
-- ДЗ-5.4.2 Информацию о студентах не имеющих оценки по :CourseName
--   среди тех, у кого он есть
create unique index on Courses using hash (CourseId)

-- Хотим по CourseName быстро получать CourseId - делаем индекс.
--   hash т.к. запросов по префиксу в ДЗ 5-7 не было, сортировка Id
--   не требуется. Однако btree с добавленным CourseId может
--   работать лучше, поэтому cтоит попробовать оба варианта и
--   выбрать лучший.
-- ДЗ-5.3.2. Информацию о студентах с :Mark по предмету :CourseName
-- ДЗ-6.1.4. Информация о студентах по :Mark и :CourseName
-- ДЗ-6.2.3. Полная информация о студентах, не имеющих оценки по
--   :CourseName
create index on Courses using hash (CourseName)

-- Хотим по LecturerName быстро получать LecturerId - делаем индекс.
--   hash т.к. запросов по префиксу в ДЗ 5-7 не было, сортировка Id
--   не требуется. Однако btree с добавленным LecturerId может
--   работать лучше, поэтому cтоит попробовать оба варианта и
--   выбрать лучший.
-- ДЗ-5.3.4. Информацию о студентах с :Mark по предмету :LecturerName
-- ДЗ-5.3.6. Информацию о студентах с :Mark по предмету :LecturerName
-- ДЗ-5.6.1. StudentId имеющих хотя бы одну оценку у :LecturerName
create index on Lecturers using hash (LecturerName)

-- {StudentId, CourseId} - PK => делаем индекс. btree т.к. составной
--   hash плохо поддерживается, а добавить Mark в дерево не сильно
--   ухудшит производительность.
-- ДЗ-5.5.2. ФИО студента и названия предметов которые у него есть
--   без оценки
-- ДЗ-6.4.1. StudentName, CourseName, долги по отсутствию оценки
-- ДЗ-6.4.2. StudentName, CourseName, долги по неудовлетворительной
--   оценке
create index on Marks using btree (StudentId, CourseId, Mark)

-- Получение студентов по предмету с заданной оценкой - частый
--   запрос. Добавим btree индекс для этого случая. Позволит
--   получать студентов, зная CourseId и Mark, а также Mark по
--   CourseId.
-- ДЗ-5.3.1. Информация о студентах с :Mark по предмету :CourseId
-- ДЗ-5.3.2. Информация о студентах с :Mark по предмету :CourseName
-- ДЗ-6.2.2. Полная информация о студентах, не имеющих оценки по
--   :CourseId
create index on Marks using btree (CourseId, Mark, StudentId)

-- Plan - таблица связей, получение курсов по группе - частый
--   запрос. Добавим btree индекс для этого случая. Составной hash
--   плохо поддерживается, с btree без сильного уудшения ветвистости
--   получим LecturerId.
-- ДЗ-5.3.3. 3.3r. Информацию о студентах с :Mark по предмету-
--   :LecturerId
-- ДЗ-5.5.2. ФИО студента и названия предметов которые у него есть
--   без оценки
-- ДЗ-5.5.3. ФИО студента и названия предметов которые у него есть,
--   но не 4 или 5
create index on Plan using btree (GroupId, CourseId, LecturerId)

-- Plan - таблица связей, получение курсов и групп по лектору -
--   частый запрос. Добавим btree индекс для этого случая. Составной
--   hash плохо поддерживается, с btree без сильного уудшения
--   ветвистости получим GroupId.
-- ДЗ-5.3.3. Информацию о студентах с :Mark по предмету :LecturerId
-- ДЗ-5.3.5. Информацию о студентах с :Mark по предмету :LecturerId
-- ДЗ-5.6.1. StudentId имеющих хотя бы одну оценку у :LecturerName
create index on Plan using btree (LecturerId, CourseId, GroupId)

-- Plan - таблица связей, получение групп по курсу - частый запрос.
--   Добавим btree индекс для этого случая. Составной hash плохо
--   поддерживается, с btree без сильного уудшения ветвистости
--   получим LecturerId.
-- ДЗ-5.4.2. Информацию о студентах не имеющих оценки по :CourseName
--   среди тех, у кого он есть
-- ДЗ-6.2.4. Полная информация о студентах, не имеющих оценки по
--   :CourseId, у которых есть этот предмет
-- ДЗ-6.2.5. Полная информация о студентах, не имеющих оценки по
--   :CourseName, у которых есть этот предмет
create index on Plan using btree (CourseId, GroupId, LecturerId)


-- 2

select avg(cast(Mark as float)) as AvgMark
from
  Marks
  natural join Students
  natural join Groups
  natural join Courses
where
  GroupName = :GroupName
  and CourseName = :CourseName

-- Хотим по GroupName быстро получать GroupId - делаем индекс. hash
--   т.к. нет запросов по префиксу и сортировка не требуется.
create index on Groups using hash (GroupName)

-- Хотим по CourseName быстро получать CourseId - делаем индекс.
--   hash т.к. нет запросов по префиксу и сортировка не требуется.
create index on Courses using hash (CourseName)

-- GroupId - FK => делаем индекс. hash т.к. получим быстрые запросы
--   на получение студентов заданной группы, а эффективно сделать
--   покрывающим не получится и сортировка id не нужна.
create index on Students using hash (GroupId)

-- Позволит обходить только дерево заданного CourseId, а в нем
--   быстро получать Mark по StudentId.
create index on Marks using btree (CourseId, StudentId, Mark)


-- 3

-- Получение распределения оценок студента
-- Пр. кол-во оценок 4 и 5 у заданного студента
select count(Mark)
from Marks
where
  Mark >= 4
  and StudentId = :StudentId

-- btree индекс хранит отсортированные оценки по данному студенту,
--   поэтому легко определить кол-во оценок с данным значением у
--   конкретногостудента, а также кол-во меньших/больших оценок.
--   Заметим, чтораньше такой индекс не требовался, т.к. надо было
--   проверять оценку только в привязке у курсу.
create index on Marks using btree (StudentId, Mark, CourseId)

-- Получение студентов данного курса на данном факультете
-- Пр. Студенты 3 курса ФИТиП
select StudentId
from
  Students
  natural join Groups
where GroupName like 'M33%'

-- btree позволит эффективно искать по префиксу названия группы.
create index on Groups using btree (GroupName, GroupId)

-- Поиск среди сотрудников (лекторов) по префиксу
-- Пр. Лекторы, фамилия которых начинается с 'Ма'
select LecturerId from Lecturers where LecturerName like 'Ма%'

-- btree позволит эффективно искать по префиксу имени лектора.
create index on Lecturers using btree (LecturerName, LecturerId)
